Extensibility:

I. Standard Extensibilities

Many patterns naturally will relate function and structure in general ways which we can understand.  Understanding these well in terms of design and extensibility is the difference between a job and a doingness. Let's take a look at how these break down.

    i.      Relating Supercomplexity toward Swith*

    Here we issue toward reuse of standard patterns in terms their manifold across and relating to the patterns issued at design and post-design time - specifically where these extend structure and therefore function beyond the simple interlinking of well understood pattern(s).

    We issue then in keeping with standard ordering logic the following:

        a. You will add components to a component

        b. You will add components to a series of components

        c. You will add components to a queue or very similar

        d. You will add components to a system or very similar

        e. You will add components to a logic

        f. You will add custom components

        g. You will add components pre/post/during design time

        h. You will need to consider connectors for such additions

        //

        a. You will latch components

        b. You will latch subcomponents

        c. You will latch applications

        d. You will latch systems

        e. You will latch networks

        f. You will latch protocols

        //

        a. You will make more or less public a component and/or system etc.

        b. You will make more or less private a component and/or system etc.

        c. You will make more or less protected a component and/or system etc.

        d. You will make more or less commutative a component and/or system etc.

        e. You will make more or less transitive a component and/or system etc.

        f. You will make more or less reflexive a component and/or system etc.

        //

        a.  You will want to offer a reference across a simple circuit and/or component

        b.  You will want to offer a reference across a complicated circuit and/or component

        c.  You will want to offer a reference across a privately held circuit and/or component

        d.  You will want to offer a reference across a shared circuit and/or component

        e.  You will want to offer re-reference across these items

        f.  You will want to add such values at runtime

        g.  You will want to add such values at compile time

        //

        a. You will want to move system components through transitivity ( question of how it will be there - time based or logic )

        b. You will want to move system components through commutativity ( question of ordering relation )

        c. You will want to move system components through reflexivity ( question of self-knowledge )

        d. You will want to move system components through

        //

        a. You will want a way to generalize system functionalities to form definition of minimal complete set

        b. You will want a way to classify system functionalities to claim form minimal complete set

        c. You will want a way to show where extends keyword is useful and why

        d. You will want a way to show where implements keyword is useful and why

        e. You will want a way to show where component features/commonalities are redundant or already concerted

        f. You will want a way to show where adding more system feature will cause a refactoring

        g. so on A+ really good so far@

        //

    Each of these will be a carry object.  We will take a look now at what this means for you, the developer.  As we progress in understanding the objects we intuit tend to mature as well.  These items will remain constant; you will expect to carry them in the delta set for reference.

    Now we need to shape our perspectives.  In what way then best to understand the relating pattern of adding, removing or altering components at pre/post/during design time, at runtime, across the permute of the list above?

        ia. Pre-Design Time

        Here we have s strong case for getting it all right to begin with.  Strong exceptions will be later adding unforeseeable requirements, lack of understandingness for it, or adding new developers or development processes. The objects here will be about gathering concepts and feelings about it the early fill-space we will conquer.

        The good or strong extensible set will maintain extensible features well.  What we will consider is how extensible the system should be.  We want the complete list of attributes to consider ahead of design time.  Here they are:

            a.  The object will need referencing

            b.  The object will need pointer reference

            c.  The object will need to be moved

            d.  The object will need a new degree of extensibility

            e.  The object will need lock(s) and/or locking features

            f.  The object will need to be encapsulated

            g.  The object will need to support an interface

            h.  The object will need a support mechanism (protocol or protocols)

            i.  The object will need to support a varying workload

            j.  The object will need to support scheduling

            k.  The object will need to use / infer logic

        These are considered two ways.  The programmer will want a clean way to move values in the 2-space of design.  The software itself will need a way to handle these at runtime.  Thus we address three things: the application, the system application and the system for design.

        Here you will want to gather system design documents that will help you guide the process towards safe and thorough completion for each step.  These documents and/or references should be read and understood by all group members ahead of starting on design proposal.

        ib. Design Time

            a. You will want to make a list of human addressables; these will be the human concept of what will be going on.  You will want to keep a design folder and a copy that show the design and theory for each step as you proceed through design and revision.

            How detailed a folder is more than subjective.  You will want something like 10 pages per design object.  You will want to create a circuit diagram, a basic write up and supporting theory for why the process supports that program, finally you will want a page stating which architects and/or designers were involved.

            This will become more interesting and usual to you as you work through the process of system and locating system components against a well understood logic for basis.  A good architect will have many successful folders illustrating his design approach and processes.  If it seems to easy you probably did not do enough work on predesign.

            //

            Example 1:  User Interface Apportionment

            Studying the field of user interfaces we see they usually are designed some three different ways.  The first way will have a monitor for actions with subscribers and listeners.  The second way will be a slightly more systematic approach and the third way would have a very systematic approach.

            These might be then that a browser will have a buttons or input dialogs written in native C or C++.  Inside the browser we find that the scripting engine indeed transfers this process to XML/HTML.  That we can rely on a system mechanism like onclick() to transfer control to a fucntion of our choosing.

            We will find above this there is indeed a total requirement for a system to manage greater system complexity.  This is where design comes into the picture.  Further we can isolate other important factors such as the degree of imposition on locating the callbacks in a system.

            //

            The boss comes to you and suggests you create a user interface proposal.  You can a) write all the code by hand and hope the complexity requirements are met by simple callback functionality, b) write an interpreter that will help you manage development complexity or c) rely on a strong system for component management.

            The case for writing it by hand is clear; you will have total control and responsibility.  An interpretive layer would also be good; you would rely on a shorthand completion for many builds and finally connect any idiosyncracies by hand for final design. The proposal would itself be helped by an XML/HTML implementation as it is easily read by human conceptual preconceptual.

            The final case is a very powerful tool for developer/developers; you can complete functional code and locate it in a mapped index.  Each functional component can be called by name and by reference as we grow the method for answering button clicks and the like.  Let's look at how far each can go in stable atmosphere before running into technical challenges.

             //

             a. By Hand

             The application will require a minimum relation with a system backing that will allow motive in relation to system components and that theory.  We would state that safely the functional code should be stored in a Function object that has a mapped property and a lookup mechanism for that function to answer some method towards response.

             There may be many systems that attend the state of execution for a button press.  There may be many dependencies on a system state and that, in turn, on behalf of some human interaction.  This to say that we will be attending some common practices to make sure we support a general method deep enough for a system architect to interface with and repeatable enough to see value in scripting and that thing.

             //

             The locking mechanism for the system state should be global and well named.  We should have a method to access it within the source code and within scripting.  We should have a relative affluence in system space with respect toward application requirements.

             The three values here are:

             i.     Unlock locked system state

             Here we state that there is a lock of finite complexity; forever locks that end up deadlocking the process itself we don't address here.  However the system will require two plumbings; one for the application and one for the system.  So a developer would be responsible for stating and characterizing the circuit for unlock and lock of his function(s).

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system blocking a threaded process.  Many things could be locked and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup condition.  We would then vie for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a person's circuit will be as large as is required and not more.


             ii.    Transfer locked system state

             Here we state that there is a lock of finite scope; locks that end up changing during transfer process we don't address here.  However the system will require two plumbings; one for transfer of reference and one for a transfer of binary code.  So a developer would be responsible for stating and characterizing the circuit for transfer under normal and failure conditions for both rereferncing and binary exchanges.

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system blocking a threaded process.  Many things could be related and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup or existing condition.  We would then care to manage reservations for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a program's circuit will be as large as is required and not more.


             iii.   Normal process (lock and unlock normally)

             Here we state that there is a lock of finite complexity; intractable locks that end up deadlocking the process or system reach itself we don't address here.  However the system will require two plumbings; one for the application and one for the system.  So a developer would be responsible for stating and characterizing the circuit for unlock and lock of his function(s).

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system a blocking threaded process.  Many things could be locked and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup condition.  We would then vie for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a person's circuit will be as large as is required and not more.


             //

             Summarily we need then a scope of circuit, data and application function separation, application circuitry for standard start, restart, pause and stop, system circuitry for standard start, restart, pause and stop, listeners for errors, listeners for exceptions, listeners for state, listeners for state transfers and perhaps more.

             If you try to write these all by hand it may become tedious and best-case vs worst-case scenarios will not always be known.  Further minor design variations will have major shifts in design if we are not careful and patience will be consumed ahead of schedule.

             Let's look at a quick example then for a button, continuing with these themes elsewhere.

             //

             public class Button0001 extends JButton implements ActionListener
             {
                    public Button0001(System system, JComponent parent)
                    {
                        //setters

                        //application calls

                        //system calls
                    }

                    public Button0001(System system, JComponent parent, CircuitGuard cg_application, CircuitGuard cg_system)
                    {
                        //setters

                        //application calls

                        //system calls
                    }

                    ...

                    public CircuitGuard circuit_guard_application;  //the application circuit we implement against; write this as agreed upon scope in design docs

                    public CircuitGuard circuit_guard_system;       //the system circuit we implement against; write this as agreed upon scope into design docs

                    public System system;                           //the topmost system we can rely on by scope or circuit

                    public SystemIntegrand integrand_system;        //logic unit for integration with system or reintegration with system

                    public ExceptionMonitor exception_monitor;      //monitor for exceptions

                    public ErrorMonitor error_monitor;              //monitor for errors

                    public StateMonitor state_monitor;              //monitor for state or change in state

                    public StateTransferMonitor transfer_monitor;   //monitor for transfer of ownership

                    public Map <String, Function> function_map;     //functional lookup by name (JNDI, etc)

                    public SystemReferencer system_referencer;      //change out this object for another like it; binary replacement or pointer alteration

                    public Data data;                               //data for this button to interact with

                    public Lock lock_system;                        //lock for system administration

                    public Lock lock_application;                   //lock for application administration

                    ...

                    public void actionPerformed(ActionEvent ae)
                    {
                        this.system.registerEvent(this, this.getBytes(), ae);
                    }
             }

             Ok, with this basic setup we can start to guarantee that system viability is protected going forward.  We would not really expect to have a simpler setup than this; stronger cases could exist for integration however.  On the other end we would like the circuits for system to be robust but we will not trade into that just yet.

             We would trade something like a hash code or binary of the object back into the system for its verification on basic state change (e.g. button press) against the system maintaining action listeners of its own for now.  This would give the system some idea about deadlock or liveness.

             //

             b. Quick Interpretive

             The quick interpretive case would have a system to convert XML/HTML to source code.  You may look online at https://github.com/mearvk/Bloq and find some examples of how this would work.

             <bloq>

                <system>

                    <handler id="exception_primary" type="exception">

                    </handler>

                    ...

                    <monitor id="state_transfer_primary" type="state_transfer">

                    </monitor>

                </system>

                <ui>

                    <jframe>

                        <data id="jframe_master" alloc="org.bloq.data.Data"/>

                        <callback type="exception" target="exception_primary"/>

                        <callback type="error" target="error_primary"/>

                        <callback type="state" target="state_primary"/>

                        <callback type="state_transfer" target="state_transfer_primary"/>

                        <jpanel>

                            <data id="jpanel_navigation" alloc="org.bloq.data.Data"/>

                            ...

                        </jpanel>

                    </jframe>

                </ui>

             </bloq>

            Here the code structure would be set once or some few times and then compiled and reworked from there.  The upside is that code and circuit function are guaranteed by the relationship between hierarchy and naming convention.

            Let's take a minute here and draft a circuit guard:

            public class CircuitGuard extends ...
            {
                public ArrayList<Object> components;                            //objects that we may need to reference

                public ArrayList<LockOrderer> lock_orderer_application;         //lock list for application to perform certain tasks

                public ArrayList<LockOrderer> lock_orderer_system;              //lock list for system to perform certain tasks

                public ArrayList<FunctionOrderer> function_orderer;             //commutative function orderer (function a --> function b --> function c)

                //

                public CircuitGuard(System system, ...)
                {
                    //setters

                    ...
                }

                public void tryCircuit()
                {
                    //
                }

                public void tryApplicationLock()
                {
                    //
                }

                public void tryApplicationUnlock()
                {
                    //
                }

                public void trySystemLock()
                {
                    //
                }

                public void trySystemUnlock()
                {
                    //
                }
            }

             c. Full Interpretive

            Finally the strong case would have a IDE with system values integrated into it.  In certain cases we would find a circuit analog would be required for software.  We would expect this to be a powerful and well supported standard.

            Things like JNDI, XML mapping(s), circuit backends, quick inferencing, and logic principalism would be supported.  Commutatation, Reflexivity, Control, Ownership, Transitivity, Redesign, etc would be considered well and kept in a clean and easy to understand software development package.

            Bloq and APML would be early examples of the underpinnings of such a system.  Such a beginning may be found at https://github.com/mearvk/Bloq for instance.  The full case would allow us to move more freely and responsively to the changing values the design may require.

            It would also serve as a well-model for education and education materials.  More on such a system later; for now a system would be quick, robust and allow users to design software quickly.  As we look into various implementational methods we will be making notes that will tie in here.

            One end would tie into sophisticated IDE and scripting language and the other would tie into a compilation engine generating source code in whichever language you chose. This is where we'd like to go with software, with design, for now. We stress that we'd like to keep people interested and happy with design.  Ok.

            //

            Example 2:  Network Interface Apportionment

            Networks are our friends.  As we've taken up locking and so forth previously as a careful part of component integration and design let's look at some of the other interesting values we could ascribe to network(s) as system components.  Ideally we have some few initial things to clear before heading into theory.

            Let's take a look a a few of them.  Firstly we would like networks to maintain a notion of interconnectivity between computers via Ethernet or TCP.  We don't mean really neural networks or a circuit that operates in a cyclic way.

            Secondly we state that networks are basically about moving data; that this data should be relatively safe.  We can and will look at how this breaks down as object references are passed instead of datagrams/packets.  Finally that we would like the networks to survive a degree of integrative complexity.

            That we would be able to add networks or network listeners at various stages of implementation.  That we would be able to remove them also.  That location of networks, their source(s), their destination(s), relative extensibility of the network as a component itself should be strong, or very strong.

            That a network interface should not give away control of a system; that we should be able to rely on a safe version in well cases.  These conceptual outlines will help you because they stay relatively still, stable.  Let look at some outlines:

            //

            public class Network extends SystemComponent
            {
                ... //standard component composition

                public Network(System system, Socket socket, ...)
                {
                    ... //
                }

                public Network(System system, ArrayList<Socket> sockets, ...)
                {
                    ... //
                }
            }

            //

            As you might intuit we could start right away with Network class and work this into the system.  This would be great.  The class above does very little else than extend SystemComponent and take Socket(s) as constructors.  Taking it up perhaps too simply what else would we need?

            The network would be reliably as extensible as a other SystemComponent but now with Network classes.  We should say famously that this will not be enough.  Here let's take up a few senior defenses of networks and the attacks they avoid.

            For instance we should state that giving a Network object to another design team, group or company as an interface would normally be thought of as very safe.  The Network object is allowed certain protocol(s) and a designer comes over to say how they will be used; this is the nature of the Application Layer in 7 layer OSI.

            What could possibly go wrong?  No, we've checked the buffer allocation and it is very clean. It cannot be overflowed.  We check the user name and password and it that the user has 60 minutes to use network per validation.  No problems so far, right?

            Well supposing your designer is very brilliant and decides to make a Checkout implementation for the Network class.  You share a company token, this is unique to your company, and for this correct value you will be returned a Network object.  Further, we could perhaps add salt to argument

            by saying we could allocate many such Checkouts across the entire scope of the public interface of the Application.  Assuming we are all trustworthy perhaps this is OK.  As we dig deeper we will explore how this may rely on a deeper sense of architectural understanding than simple Component interlinking.

            Presently that we would consider the Network implementation to only really concentrate on state, state change, and object management.  We would see to use them a one or few ways at this time for discussion.  Now that we limited some scope let's look at a few design issues.

            //

            public class Checkout extends SystemComponent implements SecurityValidator
            {
                ... //standard component composition

                public Checkout(System system, Endpoint endpoint, ...)
                {
                    ... //
                }

                public Checkout(System system, ArrayList<Endpoint> endpoints, ...)
                {
                    ... //
                }

                //

                @Override
                public void validateSecurity(SecurityToken securityToken, ...)
                {
                    //validate and return network value
                }
            }

            //

            Here the validateSecurity() function would cover validation and returning the appropriate value: the Network with unique ID and expiry for session and the like.  Here we would point out a few interesting items.  To begin the Checkout should not return

            Networks which are not the property or concern of the person/group/company requesting them.  Further that Networks should not have class members which are unsafe.  That Network A should not have class member which is not cleared by a Security mechanism, giving for instance a pointer to system for reference to Network B, some other network.

            So to include a more final proposal we should have a class that acts as a Encapsulator for grouping like objects together and that these objects should in fact limit degree of extensibility, of reach into system.

            //

            public class Encapsulator extends SystemComponent implements SecurityValidator, Validator, Aggregator
            {
                ... //standard component composition

                public Encapsulator(System system, ArrayList<SystemComponent>, ...)
                {
                    ... //
                }

                public Encapsulator(System system, ArrayList<SystemComponent>, ...)
                {
                    ... //
                }

                //

                @Override
                public void validateSecurity(SecurityToken securityToken, ...)
                {
                    //validate and return network value
                }

                @Override
                public Object validate(SecurityToken securityToken, Object object, String name)
                {
                    //validate and return object based on JDNI name, or comparator
                }

                @Override
                public void add(SecurityToken securityToken, Object object, String name)
                {
                    //add object to concern list
                }
            }

            //

            As you can see the class also has implementations for Validator and Aggregator.  These would in fact be used mainly to limit access to published system artifacts.  You would expect then any public exposed interfaces to follow this or similar pattern for restricting access to objects.

            Ideally we would want an XML or JSON file for driving these and that this would be held privately, away from an HTTP or Network request.  Since the following would be unimpressive we would look for it implemented through a Driver:

            //

            public class ClientImpl implements Runnable
            {
                ... //standard component composition

                public ClientImpl()
                {
                    ... //
                }

                //

                @Override
                public void run()
                {
                    try
                    {
                        org.our.System.qualify("jndi://remotehost:8080/systemname", "localalias", "username", "password");

                        org.our.System.lookup("localalias", "network01", "username", "password");

                        ...

                        //many small calls, etc.

                        ...

                        org.our.System.close("localalias", "network01", "username", "password");
                    }
                    catch(Exception e)
                    {
                        //reroute exception to handler
                    }
                }
            }

            Instead we would like a system interface that would clear the objects implicitly on the fly and store and respond to exceptions and errors on the basis of a circuit or similar:

            public class ClientImpl implements Runnable
            {
                ... //standard component composition

                public ClientImpl()
                {
                    ... //
                }

                //

                @Override
                public void run()
                {
                    try
                    {
                        Network pokemontrader_network;

                        pokemontrader_network = org.our.System.request(Cloner.DEEP_COPY, "jndi://remotehost:8080/systemname/network01");

                        //

                        pokemontrader_network.encapsulator.atom(Atomic.NEW);

                        //

                        pokemontrader_network.encapsulator.list("pokecard0056", 5.00, "USD");

                        pokemontrader_network.encapsulator.list("pokecard0056", 5.00, "USD");

                        ...

                        //

                        pokemontrader_network.encapsulator.atom(Atomic.COMMIT);

                        //

                        Atom transactional_atom = pokemontrader_network.encapsulator.atom(Atomic.LAST);

                        //

                        org.our.System.ui.jframe.jtabbedpane.newTabPane( pokemontrader_network.encapsulator.asList(transactional_atom) );
                    }
                    catch(Exception e)
                    {
                        //reroute exception to handler
                    }
                }

            //

            And yet clearer or perhaps better would be an XML or JSON document with clear mappings:

            //

            <network type="api" id="pokemontrader" >

                <registrar type="exceptions"> ... </registrar>

                <registrar type="jndi"> ... </registrar>



                <call name="list" local="true" class="org.their.network.Network01" atomic="enforce">

                <encapsulator value="enforce"></encapsulator>

                    <args>

                        ...

                    </args>

                </call>

            </network>

            //

            Giving a slightly more interesting look at the ClientImpl class:

            //

            public class ClientImpl implements Runnable
            {
                ... //standard component composition

                public ClientImpl()
                {
                    ... //
                }

                //

                @Override
                public void run()
                {
                    try
                    {
                        Network pokemontrader_network;

                        pokemontrader_network = org.our.System.reference("XML", "file://localhost/dir/file");

                        //

                        pokemontrader_network.atom(Atomic.NEW);

                        //

                        pokemontrader_network.function("list").args("pokecard0056", 5.00, "USD");

                        pokemontrader_network.function("list").args("pokecard0056", 5.00, "USD");

                        ...

                        //

                        pokemontrader_network.atom(Atomic.COMMIT);

                        //

                        Atom transactional_atom = pokemontrader_network.atom(Atomic.LAST);

                        //

                        org.our.System.ui.jframe.jtabbedpane.newTabPane( pokemontrader_network.asList(transactional_atom) );
                    }
                    catch(Exception e)
                    {
                        //reroute exception to handler
                    }
                }

            This will be ahead in a critical way; some meaningful extensibility will have been preserved.  Now instead of relying on a precompiled value at the level of third-party encapsulator and a published API document we have a direct list of values which can be agreed upon ahead of time.

            The system maintains a degree of relation which stays constant with respect to an interface instead of the Encapsulator's concrete class.  This will be all for now.  We will look later at how Network interfaces can be added or removed from system safely with all this in swing.

            This will be a strong case for system security, protecting your system from being copied, unintended effects and design decisions that must be connected later than we would like.  The Network addresses all these and so we will take this component up as an exemplar.

             //

            Example 3: Tray the System

            In this case we would look at the value utility of deep clone vs shallow clone or pass by reference.  Deep cloning of course allows the program to move between JVMs more permanently than pass by reference.  This will produce interesting theory for system and security results and/or designs. Good night.

            //

        ic. Post-Design Time

        id. Runtime

        ie. Errata

    We issue then in keeping with standard ordering logic the following:

        a. In extensible set a component must be

        b. In extensible set a component must be

    ii.     Direct System Related Extensibility Mapping

    The backing system is the object here; as we add to the program we need the extensibility in terms of speed and ease.  We add functionality in terms of understanding to maintain this edge in the sort.

    iii.    Indirect System Related Extensibility Mapping

    The programmer and/or designer are the object here.  Clear cut case of adding complexity by adding external constraints that are not a direct system value.

    iv.     Reorganization and Cleanliness

II. Specific Extensibilities

Certain patterns will have specific


Terms:

Swith: Super-smooth, low-latency coolness,, again

Darth: Break-even point for emperor

