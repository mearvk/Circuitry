Extensibility:

I. Standard Extensibilities

Many patterns naturally will relate function and structure in general ways which we can understand.  Understanding these well in terms of design and extensibility is the difference between a job and a doingness. Let's take a look at how these break down.

    i.      Relating Supercomplexity toward Swith*

    Here we issue toward reuse of standard patterns in terms their manifold across and relating to the patterns issued at design and post-design time - specifically where these extend structure and therefore function beyond the simple interlinking of well understood pattern(s).

    We issue then in keeping with standard ordering logic the following:

        a. You will add components to a component

        b. You will add components to a series of components

        c. You will add components to a queue or very similar

        d. You will add components to a system or very similar

        e. You will add components to a logic

        f. You will add custom components

        g. You will add components pre/post/during design time

        h. You will need to consider connectors for such additions

        //

        a. You will latch components

        b. You will latch subcomponents

        c. You will latch applications

        d. You will latch systems

        e. You will latch networks

        f. You will latch protocols

        //

        a. You will make more or less public a component and/or system etc.

        b. You will make more or less private a component and/or system etc.

        c. You will make more or less protected a component and/or system etc.

        d. You will make more or less commutative a component and/or system etc.

        e. You will make more or less transitive a component and/or system etc.

        f. You will make more or less reflexive a component and/or system etc.

        //

        a.  You will want to offer a reference across a simple circuit and/or component

        b.  You will want to offer a reference across a complicated circuit and/or component

        c.  You will want to offer a reference across a privately held circuit and/or component

        d.  You will want to offer a reference across a shared circuit and/or component

        e.  You will want to offer re-reference across these items

        f.  You will want to add such values at runtime

        g.  You will want to add such values at compile time

        //

        a. You will want to move system components through transitivity ( question of how it will be there - time based or logic )

        b. You will want to move system components through commutativity ( question of ordering relation )

        c. You will want to move system components through reflexivity ( question of self-knowledge )

        //

        a. You will want a way to generalize system functionalities to form minimal complete set

        b. You will want a way to classify system functionalities to form minimal complete set

        c. You will want a way to show where extends keyword is useful and why

        d. You will want a way to show where implements keyword is useful and why

        e. You will want a way to show where component features/commonalities are redundant or already well

        f. You will want a way to show

        //

    Each of these will be a carry object.  We will take a look now at what this means for you, the developer.  As we progress in understanding the objects we intuit tend to mature as well.  These items will remain constant; you will expect to carry them in the delta set for reference.

    Now we need to shape our perspectives.  In what way then best to understand the relating pattern of adding, removing or altering components at pre/post/during design time, at runtime, across the permute of the list above?

        ia. Pre-Design Time

        Here we have s strong case for getting it all right to begin with.  Strong exceptions will be later adding unforeseeable requirements, lack of understandingness for it, or adding new developers or development processes. The objects here will be about gathering concepts and feelings about it the early fill-space we will conquer.

        The good or strong extensible set will maintain extensible features well.  What we will consider is how extensible the system should be.  We want the complete list of attributes to consider ahead of design time.  Here they are:

            a.  The object will need referencing

            b.  The object will need pointer reference

            c.  The object will need to be moved

            d.  The object will need a new degree of extensibility

            e.  The object will need lock(s) and/or locking features

            f.  The object will need to be encapsulated

            g.  The object will need to support an interface

            h.  The object will need a support mechanism (protocol or protocols)

            i.  The object will need to support a varying workload

            j.  The object will need to support scheduling

            k.  The object will need to use / infer logic

        These are considered two ways.  The programmer will want a clean way to move values in the 2-space of design.  The software itself will need a way to handle these at runtime.  Thus we address three things: the application, the system application and the system for design.

        ib. Design Time

            a.

        ic. Post-Design Time

        id. Runtime

        ie. Errata

    We issue then in keeping with standard ordering logic the following:

        a. In extensible set a component must be

        b. In extensible set a component must be

    ii.     Direct System Related Extensibility Mapping

    The backing system is the object here; as we add to the program we need the extensibility in terms of speed and ease.  We add functionality in terms of understanding to maintain this edge in the sort.

    iii.    Indirect System Related Extensibility Mapping

    The programmer and/or designer are the object here.  Clear cut case of adding complexity by adding external constraints that are not a direct system value.

    iv.     Reorganization and Cleanliness

II. Specific Extensibilities

Certain patterns will have specific


Terms:

Swith: Super-smooth, low-latency coolness,, again

Darth: Break-even point for emperor

