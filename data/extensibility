Extensibility:

I. Standard Extensibilities

Many patterns naturally will relate function and structure in general ways which we can understand.  Understanding these well in terms of design and extensibility is the difference between a job and a doingness. Let's take a look at how these break down.

    i.      Relating Supercomplexity toward Swith*

    Here we issue toward reuse of standard patterns in terms their manifold across and relating to the patterns issued at design and post-design time - specifically where these extend structure and therefore function beyond the simple interlinking of well understood pattern(s).

    We issue then in keeping with standard ordering logic the following:

        Additivity x. By additivity we mean that there will be acts of addition and we treat these as a theorem.  Here we list the a complete additive properties list for software design.

        a. You will add components to a component

        b. You will add components to a series of components

        c. You will add components to a queue or very similar

        d. You will add components to a system or very similar

        e. You will add components to a logic

        f. You will add custom components

        g. You will add components pre/post/during design time

        h. You will need to consider connectors for such additions

        //

        Locking x. By locking we mean there will be a runtime software lock available for a resource, resources or process and that these will be well specified and safe.  That there will be some Guarantor for sanity throughout the process of using it, the runtime locking system.

        a. You will lock/unlock components

        b. You will lock/unlock subcomponents

        c. You will lock/unlock applications

        d. You will lock/unlock systems

        e. You will lock/unlock networks

        f. You will lock/unlock protocols

        g. You will lock/unlock latches

        h. You will have locks based on kinds of problems

        i. You will have locks based on kinds of components

        //

        Latching x. By latching we mean a component will have a clear, usually simple connection process from one component to another component or components.  These can be above, below, or with in terms of hierarchy or before, simultaneous or after in terms of execution.  These are structured relevances.

        a. You will latch components

        b. You will latch subcomponents

        c. You will latch applications

        d. You will latch systems

        e. You will latch networks

        f. You will latch protocols

        //

        Component Properties x. By properties we mean the basic properties a system component would have.  These are listed below.  This capacitates to be a full list.

        a. You will make more or less public a component and/or system etc.

        b. You will make more or less private a component and/or system etc.

        c. You will make more or less protected a component and/or system etc.

        d. You will make more or less commutative a component and/or system etc. [ x ]

        e. You will make more or less transitive a component and/or system etc.  [ a . a . b ≈ b . c . ã == a . a . b ≈ b . c . ã . a ]

        f. You will make more or less reflexive a component and/or system etc. [ x ]

        g. You will make more or less imponent (input specificity) a component and/or system etc. [ a -> b ≈ a -> bb is no]

        //

        Referencing x. By ... we mean

        a.  You will want to offer a reference across a simple circuit and/or component

        b.  You will want to offer a reference across a complicated circuit and/or component

        c.  You will want to offer a reference across a privately held circuit and/or component

        d.  You will want to offer a reference across a shared circuit and/or component

        e.  You will want to offer re-reference across these items

        f.  You will want to add such values at runtime

        g.  You will want to add such values at compile time

        //

        Modement x.

        a. You will want to move system components through transitivity ( question of how it will be there - time based or logic )

        b. You will want to move system components through commutativity ( question of ordering relation )

        c. You will want to move system components through reflexivity ( question of self-knowledge )

        d. You will want to move system components through

        //

        General Valuations x.

        a. You will want a way to generalize system functionalities to form definition of minimal complete set

        b. You will want a way to classify system functionalities to claim form minimal complete set

        c. You will want a way to show where extends keyword is useful and why

        d. You will want a way to show where implements keyword is useful and why

        e. You will want a way to show where component features/commonalities are redundant or already concerted

        f. You will want a way to show where adding more system feature will cause a refactoring

        //

        Contractual Assignments x.

        a. You will want a contract grade circuit for specifying/guaranteeing timing

        b. You will want a contract grade circuit for specifying/guaranteeing ordering

        c. You will want a contract grade circuit for specifying/guaranteeing data state

        d. You will want a contract grade circuit for specifying/guaranteeing scale as a factor

        e. You will want a contract grade circuit for specifying/guaranteeing what can be traded and how

        f. You will want a contract grade circuit for specifying/guaranteeing safety

        //

    Each of these will be a carry object.  We will take a look now at what this means for you, the developer.  As we progress in understanding the objects we intuit tend to mature as well.  These items will remain constant; you will expect to carry them in the delta set for reference.

    Now we need to shape our perspectives.  In what way then best to understand the relating pattern of adding, removing or altering components at pre/post/during design time, at runtime, across the permute of the list above?

        ia. Pre-Design Time

        Here we have s strong case for getting it all right to begin with.  Strong exceptions will be later adding unforeseeable requirements, lack of understandingness for it, or adding new developers or development processes. The objects here will be about gathering concepts and feelings about it the early fill-space we will conquer.

        The good or strong extensible set will maintain extensible features well.  What we will consider is how extensible the system should be.  We want the complete list of attributes to consider ahead of design time.  Here they are:

            a.  The object will need referencing

            b.  The object will need pointer reference

            c.  The object will need to be moved

            d.  The object will need a new degree of extensibility

            e.  The object will need lock(s) and/or locking features

            f.  The object will need to be encapsulated

            g.  The object will need to support an interface

            h.  The object will need a support mechanism (protocol or protocols)

            i.  The object will need to support a varying workload

            j.  The object will need to support scheduling

            k.  The object will need to use / infer logic

        These are considered two ways.  The programmer will want a clean way to move values in the 2-space of design.  The software itself will need a way to handle these at runtime.  Thus we address three things: the application, the system application and the system for design.

        Here you will want to gather system design documents that will help you guide the process towards safe and thorough completion for each step.  These documents and/or references should be read and understood by all group members ahead of starting on design proposal.

        ib. Design Time

            a. You will want to make a list of human addressables; these will be the human concept of what will be going on.  You will want to keep a design folder and a copy that show the design and theory for each step as you proceed through design and revision.

            How detailed a folder is more than subjective.  You will want something like 10 pages per design object.  You will want to create a circuit diagram, a basic write up and supporting theory for why the process supports that program, finally you will want a page stating which architects and/or designers were involved.

            This will become more interesting and usual to you as you work through the process of system and locating system components against a well understood logic for basis.  A good architect will have many successful folders illustrating his design approach and processes.  If it seems to easy you probably did not do enough work on predesign.

            //

            Example 1:  User Interface Apportionment

            Studying the field of user interfaces we see they usually are designed some three different ways.  The first way will have a monitor for actions with subscribers and listeners.  The second way will be a slightly more systematic approach and the third way would have a very systematic approach.

            These might be then that a browser will have a buttons or input dialogs written in native C or C++.  Inside the browser we find that the scripting engine indeed transfers this process to XML/HTML.  That we can rely on a system mechanism like onclick() to transfer control to a fucntion of our choosing.

            We will find above this there is indeed a total requirement for a system to manage greater system complexity.  This is where design comes into the picture.  Further we can isolate other important factors such as the degree of imposition on locating the callbacks in a system.

            //

            The boss comes to you and suggests you create a user interface proposal.  You can a) write all the code by hand and hope the complexity requirements are met by simple callback functionality, b) write an interpreter that will help you manage development complexity or c) rely on a strong system for component management.

            The case for writing it by hand is clear; you will have total control and responsibility.  An interpretive layer would also be good; you would rely on a shorthand completion for many builds and finally connect any idiosyncracies by hand for final design. The proposal would itself be helped by an XML/HTML implementation as it is easily read by human conceptual preconceptual.

            The final case is a very powerful tool for developer/developers; you can complete functional code and locate it in a mapped index.  Each functional component can be called by name and by reference as we grow the method for answering button clicks and the like.  Let's look at how far each can go in stable atmosphere before running into technical challenges.

             //

             a. By Hand

             The application will require a minimum relation with a system backing that will allow motive in relation to system components and that theory.  We would state that safely the functional code should be stored in a Function object that has a mapped property and a lookup mechanism for that function to answer some method towards response.

             There may be many systems that attend the state of execution for a button press.  There may be many dependencies on a system state and that, in turn, on behalf of some human interaction.  This to say that we will be attending some common practices to make sure we support a general method deep enough for a system architect to interface with and repeatable enough to see value in scripting and that thing.

             //

             The locking mechanism for the system state should be global and well named.  We should have a method to access it within the source code and within scripting.  We should have a relative affluence in system space with respect toward application requirements.

             The three values here are:

             i.     Unlock locked system state

             Here we state that there is a lock of finite complexity; forever locks that end up deadlocking the process itself we don't address here.  However the system will require two plumbings; one for the application and one for the system.  So a developer would be responsible for stating and characterizing the circuit for unlock and lock of his function(s).

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system blocking a threaded process.  Many things could be locked and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup condition.  We would then vie for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a person's circuit will be as large as is required and not more.


             ii.    Transfer locked system state

             Here we state that there is a lock of finite scope; locks that end up changing during transfer process we don't address here.  However the system will require two plumbings; one for transfer of reference and one for a transfer of binary code.  So a developer would be responsible for stating and characterizing the circuit for transfer under normal and failure conditions for both rereferncing and binary exchanges.

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system blocking a threaded process.  Many things could be related and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup or existing condition.  We would then care to manage reservations for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a program's circuit will be as large as is required and not more.


             iii.   Normal process (lock and unlock normally)

             Here we state that there is a lock of finite complexity; intractable locks that end up deadlocking the process or system reach itself we don't address here.  However the system will require two plumbings; one for the application and one for the system.  So a developer would be responsible for stating and characterizing the circuit for unlock and lock of his function(s).

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system a blocking threaded process.  Many things could be locked and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup condition.  We would then vie for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a person's circuit will be as large as is required and not more.


             //

             Summarily we need then a scope of circuit, data and application function separation, application circuitry for standard start, restart, pause and stop, system circuitry for standard start, restart, pause and stop, listeners for errors, listeners for exceptions, listeners for state, listeners for state transfers and perhaps more.

             If you try to write these all by hand it may become tedious and best-case vs worst-case scenarios will not always be known.  Further minor design variations will have major shifts in design if we are not careful and patience will be consumed ahead of schedule.

             Let's look at a quick example then for a button, continuing with these themes elsewhere.

             //

             public class Button0001 extends JButton implements ActionListener
             {
                    public Button0001(System system, JComponent parent)
                    {
                        //setters

                        //application calls

                        //system calls
                    }

                    public Button0001(System system, JComponent parent, CircuitGuard cg_application, CircuitGuard cg_system)
                    {
                        //setters

                        //application calls

                        //system calls
                    }

                    ...

                    public CircuitGuard circuit_guard_application;  //the application circuit we implement against; write this as agreed upon scope in design docs

                    public CircuitGuard circuit_guard_system;       //the system circuit we implement against; write this as agreed upon scope into design docs

                    public System system;                           //the topmost system we can rely on by scope or circuit

                    public SystemIntegrand integrand_system;        //logic unit for integration with system or reintegration with system

                    public ExceptionMonitor exception_monitor;      //monitor for exceptions

                    public ErrorMonitor error_monitor;              //monitor for errors

                    public StateMonitor state_monitor;              //monitor for state or change in state

                    public StateTransferMonitor transfer_monitor;   //monitor for transfer of ownership

                    public Map <String, Function> function_map;     //functional lookup by name (JNDI, etc)

                    public SystemReferencer system_referencer;      //change out this object for another like it; binary replacement or pointer alteration

                    public Data data;                               //data for this button to interact with

                    public Lock lock_system;                        //lock for system administration

                    public Lock lock_application;                   //lock for application administration

                    ...

                    public void actionPerformed(ActionEvent ae)
                    {
                        this.system.registerEvent(this, this.getBytes(), ae);
                    }
             }

             //

             Ok, with this basic setup we can start to guarantee that system viability is protected going forward.  We would not really expect to have a simpler setup than this; stronger cases could exist for integration however.  On the other end we would like the circuits for system to be robust but we will not trade into that just yet.

             We would trade something like a hash code or binary of the object back into the system for its verification on basic state change (e.g. button press) against the system maintaining action listeners of its own for now.  This would give the system some idea about deadlock or liveness.

             //

             b. Quick Interpretive

             The quick interpretive case would have a system to convert XML/HTML to source code.  You may look online at https://github.com/mearvk/Bloq and find some examples of how this would work.

             <bloq>

                <system>

                    <handler id="exception_primary" type="exception">

                    </handler>

                    ...

                    <monitor id="state_transfer_primary" type="state_transfer">

                    </monitor>

                </system>

                <ui>

                    <jframe>

                        <data id="jframe_master" alloc="org.bloq.data.Data"/>

                        <callback type="exception" target="exception_primary"/>

                        <callback type="error" target="error_primary"/>

                        <callback type="state" target="state_primary"/>

                        <callback type="state_transfer" target="state_transfer_primary"/>

                        <jpanel>

                            <data id="jpanel_navigation" alloc="org.bloq.data.Data"/>

                            ...

                        </jpanel>

                    </jframe>

                </ui>

             </bloq>

            Here the code structure would be set once or some few times and then compiled and reworked from there.  The upside is that code and circuit function are guaranteed by the relationship between hierarchy and naming convention.

            Quickly let's regard the XML as valuable.  We would care for instance that the XML document remain that way.  Adding many components after the fact would be additive and in some case would cause the system to be redone, designed again.

            Ideally we would then want to lay system components as final, the top-most value and then allow latching only downwardly.  We make note of that ideal here.

            Let's take a minute here and draft a circuit guard:

            public class CircuitGuard extends ...
            {
                public ArrayList<Object> components;                            //objects that we may need to reference

                public ArrayList<LockOrderer> lock_orderer_application;         //lock list for application to perform certain tasks

                public ArrayList<LockOrderer> lock_orderer_system;              //lock list for system to perform certain tasks

                public ArrayList<FunctionOrderer> function_orderer;             //commutative function orderer (function a --> function b --> function c)

                //

                public CircuitGuard(System system, ...)
                {
                    //setters

                    ...
                }

                public void tryCircuit()
                {
                    //
                }

                public void tryApplicationLock()
                {
                    //
                }

                public void tryApplicationUnlock()
                {
                    //
                }

                public void trySystemLock()
                {
                    //
                }

                public void trySystemUnlock()
                {
                    //
                }
            }

             c. Full Interpretive

            Finally the strong case would have a IDE with system values integrated into it.  In certain cases we would find a circuit analog would be required for software.  We would expect this to be a powerful and well supported standard.

            Things like JNDI, XML mapping(s), circuit backends, quick inferencing, and logic principalism would be supported.  Commutatation, Reflexivity, Control, Ownership, Transitivity, Redesign, etc would be considered well and kept in a clean and easy to understand software development package.

            Bloq and APML would be early examples of the underpinnings of such a system.  Such a beginning may be found at https://github.com/mearvk/Bloq for instance.  The full case would allow us to move more freely and responsively to the changing values the design may require.

            It would also serve as a well-model for education and education materials.  More on such a system later; for now a system would be quick, robust and allow users to design software quickly.  As we look into various implementational methods we will be making notes that will tie in here.

            One end would tie into sophisticated IDE and scripting language and the other would tie into a compilation engine generating source code in whichever language you chose. This is where we'd like to go with software, with design, for now. We stress that we'd like to keep people interested and happy with design.  Ok.

            //

            Example 2:  Network Interface Apportionment

            Networks are our friends.  As we've taken up locking and so forth previously as a careful part of component integration and design let's look at some of the other interesting values we could ascribe to network(s) as system components.  Ideally we have some few initial things to clear before heading into theory.

            Let's take a look a a few of them.  Firstly we would like networks to maintain a notion of interconnectivity between computers via Ethernet or TCP.  We don't mean really neural networks or a circuit that operates in a cyclic way.

            Secondly we state that networks are basically about moving data; that this data should be relatively safe.  We can and will look at how this breaks down as object references are passed instead of datagrams/packets.  Finally that we would like the networks to survive a degree of integrative complexity.

            That we would be able to add networks or network listeners at various stages of implementation.  That we would be able to remove them also.  That location of networks, their source(s), their destination(s), relative extensibility of the network as a component itself should be strong, or very strong.

            That a network interface should not give away control of a system; that we should be able to rely on a safe version in well cases.  These conceptual outlines will help you because they stay relatively still, stable.  Let look at some outlines:

            //

            public class Network extends SystemComponent
            {
                ... //standard component composition

                public Network(System system, Socket socket, ...)
                {
                    ... //
                }

                public Network(System system, ArrayList<Socket> sockets, ...)
                {
                    ... //
                }
            }

            //

            As you might intuit we could start right away with Network class and work this into the system.  This would be great.  The class above does very little else than extend SystemComponent and take Socket(s) as constructors.  Taking it up perhaps too simply what else would we need?

            The network would be reliably as extensible as a other SystemComponent but now with Network classes.  We should say famously that this will not be enough.  Here let's take up a few senior defenses of networks and the attacks they avoid.

            For instance we should state that giving a Network object to another design team, group or company as an interface would normally be thought of as very safe.  The Network object is allowed certain protocol(s) and a designer comes over to say how they will be used; this is the nature of the Application Layer in 7 layer OSI.

            What could possibly go wrong?  No, we've checked the buffer allocation and it is very clean. It cannot be overflowed.  We check the user name and password and it that the user has 60 minutes to use network per validation.  No problems so far, right?

            Well supposing your designer is very brilliant and decides to make a Checkout implementation for the Network class.  You share a company token, this is unique to the 3rd party company, and for this correct value you will be returned a Network object.  Further, we could perhaps add salt to argument

            by saying we could allocate many such Checkouts across the entire scope of the public interface of the Application.  Assuming we are all trustworthy perhaps this is OK.  As we dig deeper we will explore how this may rely on a deeper sense of architectural understanding than simple Component interlinking.

            Presently that we would consider the Network implementation to only really concentrate on state, state change, and object management.  We would see to use them a one or few ways at this time for discussion.  Now that we limited some scope let's look at a few design issues.

            //

            public class Checkout extends SystemComponent implements SecurityValidator
            {
                ... //standard component composition

                public Checkout(System system, Endpoint endpoint, ...)
                {
                    ... //
                }

                public Checkout(System system, ArrayList<Endpoint> endpoints, ...)
                {
                    ... //
                }

                //

                @Override
                public void validateSecurity(SecurityToken securityToken, ...)
                {
                    //validate and return network value
                }
            }

            //

            Here the validateSecurity() function would cover validation and returning the appropriate value: the Network with unique ID and expiry for session and the like.  Here we would point out a few interesting items.  To begin the Checkout should not return

            Networks which are not the property or concern of the person/group/company requesting them.  Further that Networks should not have class members which are unsafe.  That Network A should not have class member which is not cleared by a Security mechanism, giving for instance a pointer to system for reference to Network B, some other network.

            So to include a more final proposal we should have a class that acts as a Encapsulator for grouping like objects together and that these objects should in fact limit degree of extensibility, of reach into system.

            //

            public class Encapsulator extends SystemComponent implements SecurityValidator, Validator, Aggregator
            {
                ... //standard component composition

                public Encapsulator(System system, ArrayList<SystemComponent>, ...)
                {
                    ... //
                }

                public Encapsulator(System system, ArrayList<SystemComponent>, ...)
                {
                    ... //
                }

                //

                @Override
                public void validateSecurity(SecurityToken securityToken, ...)
                {
                    //validate and return network value
                }

                @Override
                public Object validate(SecurityToken securityToken, Object object, String name)
                {
                    //validate and return object based on JDNI name, or comparator
                }

                @Override
                public void add(SecurityToken securityToken, Object object, String name)
                {
                    //add object to concern list
                }
            }

            //

            As you can see the class also has implementations for Validator and Aggregator.  These would in fact be used mainly to limit access to published system artifacts.  You would expect then any public exposed interfaces to follow this or similar pattern for restricting access to objects.

            Ideally we would want an XML or JSON file for driving these and that this would be held privately, away from an HTTP or Network request.  Since the following would be unimpressive we would look for it implemented through a Driver:

            //

            public class ClientImpl implements Runnable
            {
                ... //standard component composition

                public ClientImpl()
                {
                    ... //
                }

                //

                @Override
                public void run()
                {
                    try
                    {
                        org.our.System.qualify("jndi://remotehost:8080/systemname", "localalias", "username", "password");

                        org.our.System.lookup("localalias", "network01", "username", "password");

                        ...

                        //many small calls, etc.

                        ...

                        org.our.System.close("localalias", "network01", "username", "password");
                    }
                    catch(Exception e)
                    {
                        //reroute exception to handler
                    }
                }
            }

            Instead we would like a system interface that would clear the objects implicitly on the fly and store and respond to exceptions and errors on the basis of a circuit or similar:

            public class ClientImpl implements Runnable
            {
                ... //standard component composition

                public ClientImpl()
                {
                    ... //
                }

                //

                @Override
                public void run()
                {
                    try
                    {
                        Network pokemontrader_network;

                        pokemontrader_network = org.our.System.request(Cloner.DEEP_COPY, "jndi://remotehost:8080/systemname/network01");

                        //

                        pokemontrader_network.encapsulator.atom(Atomic.NEW);

                        //

                        pokemontrader_network.encapsulator.list("pokecard0056", 5.00, "USD");

                        pokemontrader_network.encapsulator.list("pokecard0056", 5.00, "USD");

                        ...

                        //

                        pokemontrader_network.encapsulator.atom(Atomic.COMMIT);

                        //

                        Atom transactional_atom = pokemontrader_network.encapsulator.atom(Atomic.LAST);

                        //

                        org.our.System.ui.jframe.jtabbedpane.newTabPane( pokemontrader_network.encapsulator.asList(transactional_atom) );
                    }
                    catch(Exception e)
                    {
                        //reroute exception to handler
                    }
                }

            //

            And yet clearer or perhaps better would be an XML or JSON document with clear mappings:

            //

            <network type="api" id="pokemontrader" >

                <registrar type="exceptions"> ... </registrar>

                <registrar type="jndi"> ... </registrar>

                <registrar type="event"> ... </registrar>



                <call name="list" local="true" class="org.their.network.Network01" atomic="enforce" jndi="jndi://remotehost:8080/system/branch/target001">

                <encapsulator value="enforce"></encapsulator>

                    <args>

                        ...

                    </args>

                </call>

                <call name="list" local="true" class="org.their.network.Network01" atomic="enforce" jndi="jndi://remotehost:8080/system/branch/target002">

                <encapsulator value="enforce"></encapsulator>

                    <args>

                        ...

                    </args>

                </call>

            </network>

            //

            Giving a slightly more interesting look at the ClientImpl class:

            //

            public class ClientImpl implements Runnable
            {
                ... //standard component composition

                public ClientImpl()
                {
                    ... //
                }

                //

                @Override
                public void run()
                {
                    try
                    {
                        Network pokemontrader_network;

                        pokemontrader_network = org.our.System.reference("XML", "file://localhost/dir/file");

                        //

                        pokemontrader_network.atom(Atomic.NEW);

                        //

                        pokemontrader_network.function("target001/list").args("pokecard0056", 5.00, "USD");             //one system object - target001

                        pokemontrader_network.function("target002/list").args("pokecard0056", 5.00, "USD");             //one system object - target002

                        ...

                        //

                        pokemontrader_network.atom(Atomic.COMMIT);

                        //

                        Atom transactional_atom = pokemontrader_network.atom(Atomic.LAST);

                        //

                        org.our.System.ui.jframe.jtabbedpane.newTabPane( pokemontrader_network.asList(transactional_atom) );
                    }
                    catch(Exception e)
                    {
                        //reroute exception to handler
                    }
                }

            This will be ahead in a critical way; some meaningful extensibility will have been preserved.  Now instead of relying on a precompiled value at the level of third-party encapsulator and a published API document we have a direct list of values which can be agreed upon ahead of time.

            The system maintains a degree of relation which stays constant with respect to an interface instead of the Encapsulator's concrete class.  This will be all for now.  We will look later at how Network interfaces can be added or removed from system safely with all this in swing.

            This will be a strong case for system security, protecting your system from being copied, unintended effects and design decisions that must be connected/implemented/added/removed later than we would like.  The Network addresses all these and so we will take this component up as an exemplar.

             //

            Example 3: Tray the System

            In this case we would look at the value utility of deep clone vs shallow clone or pass by reference.  Deep cloning of course allows the program to move between JVMs more permanently than pass by reference.  This will produce interesting theory for system and security results and/or designs.

            Firstly let's be aware of the security risk of Software as a Service (SaaS).  Primarily we would like a system as the top-most node.  That is, we ask for a service by name and get a SystemComponent back, a system implementation or harness.

            We cover some security issues with the Network class, let's look at what we'd like to protect in design and extensibility as far as traying the system.

            In covering deep cloning we should be aware that when we give a reference to a system object we give away some control over that object.  We have some care to deliver only the correct amount of control to the end-user.  If we publish an API

            that API should not give access to specific components and properties which we do not intend to cover ahead in control theory.  The SaaS model intends this; that deliver of a Service will be only the right amount of access to the object or system.

            Insofar as we care we must then be careful to deliver the proper commutative sequence.  The system generally then should not have the following:

                a. Network interface(s) which allow direct object reference(s)

                b. Network interface(s) which do not have careful Encapsulator(s) classes

                c. Network interfaces(s) which allow network control of system

                d. Adding/altering/removing of interface(s) which allow a, b and/or c.

                e. Meaningful contractual revision of intent across these

            We would then be sure to write very carefully these against, if they became part of a required, approvable system specification, further expectations which would look something like;

                a. Direct references effectively would not allow deep cloning without security measure(s)

                b. Direct references of system objects would not be swappable without security measure(s)

                c. Private data could not be stored in the object itself without security measures(s) [ i.e. hashed versions of passwords only ]

                d. Security data could not be stored in the object itself without security measure(s) [ protected API calls, protected values ]

                e. Private/secure data would not be part of a cloned object beyond agreed upon system state [ newly cloned objects would not pass a singleton test for example ]

            In the general case let's take care to guard then the following as markedly important, guarded:

                a. Cloning of objects

                b. Security state as unguardedly preeminent

                c. Private data as unguardedly preeminent

                d. Networks of a kind would be used; not simple access to objects

                Carefully that no data should exist in the system as ready ahead of a SystemComponent model for guaranteeing it is safe and coherent.  That private data should not be held in the clear, rather that it should be encrypted or controlled.

                That therefore there should be a safe, top-most token for verifying each transaction in the application and/or system.  That security tokens should be well held, unavailable toward exception in the case of cloning, intentional or otherwise.

                The features support well a client/server model where we ask for values through strong getter/setter models that prove Encapsulation is a well integrated property of the system's design.  Looking then at the few basic models we could share as careful:

            //

            Model One would have a direct reference to the object, and here we leave the inherent integrity issue(s) as well kept.  As noted the security issue would be that clones could be made remotely and these clones could be misused.  The direct object then would have some care

            toward protecting its instance members and that as a security concern.  A private resource may not be enough to guard against misuse by an experienced blackhat hacker, as a way to understand the issue or problem(s).  Here for instance many books could be written on this subject

            directly, many courses offered at fine Universities.


            public class Server implements SecurityValidator, Validator, JNDISystemComponentServer
            {
                public Server(System system, ...)
                {
                    ... //
                }

                @Override
                public SystemComponent doGet(SecurityToken token, String name, ...)
                {
                    ... //
                }

                @Override
                public SystemComponent doPut(SecurityToken token, String name, ...)
                {
                    ... //
                }

                ... //

                @Override
                public Boolean validate(Object target, ...)
                {
                    ... //
                }
            }

            //

            Example 4: Runtime Dependencies

            In this case we would look at costs of shuffling or reordering SystemComponent modules at runtime.  The standard system is related by hierarchical ordering or indeed a JDNI mapping.  The are fine for pre-compile or design time.  We would like to discuss with you the costs

            of shuffling components during the operational phase of system.  Some examples would be duplicating a system on the fly as new hardware came online; another example would be adding a Network component with SecurityValidator, Validator, Server implementation into an existing system and how to

            decide on the extensibilities for that option.  Finally we would like to discuss reordering references in the general case, and a slightly more complex case.  Here we would also look at a DocumentOptix or DocumentLoader for the system designer.  Remember all these things

            should be easy for the experience system administrator to work with and bread and butter for the system developer.  Let's then take a look a some case examples:

            //

            As starting from above we can see that offering a Service interface for the system may indeed be the superior in many ways to a local concrete implementation.  In avoiding a pitfall, we should look to an appropriate methodology for start.

            public class System001 extends System implements SecurityValidator, Validator
            {

            }

            public class Copier extends SystemComponent implements SecurityValidator, Validator
            {
                //copier prunes invalid before sending
            }

            public class Monitor001 extends Endpoint implements SecurityValidator, Validator
            {

            }

            public class Monitor002 extends Endpoint implements SecurityValidator, Validator
            {

            }

            ...

            public class ClientImpl extends SystemComponent implements Runnable
            {
                public ClientImpl(System system, ...)
                {
                    ... //
                }

                @Override
                public void run()
                {
                    org.our.System.function("jndi/lookup").args("jndi://localhost:8080/system001", "jndi/system001");  *STRONG CASE*

                    //

                    System001 system;

                    system = (org.our.System001) org.our.System.alias("jndi/system001").shallow_copy();

                    //

                    system.service("pause").args(system.copier);

                    system.service("pause").args(system.monitor001);

                    system.service("pause").args(system.monitor002);

                    //

                    system.service("add").args(system.copier.components, network005);

                    system.service("add").args(system.monitor001.components, network005);

                    system.service("add").args(system.monitor002.components, network005);

                    //

                    system.service("remove").args(system.copier.components, ALL);

                    //

                    system.service("add").rules("file://localhost/file").args(system.copier.components, ON_COPY);

                    system.service("add").rules("file://localhost/file").args(system.monitor001.components, INTERFACE_ACTION);

                    system.service("add").rules("file://localhost/file").args(system.monitor002.components, INTERFACE_ACTION);

                    //

                    system.service("resume").args(system.copier);

                    system.service("resume").args(system.monitor001);

                    system.service("resume").args(system.monitor002);

                    //

                    system.service("notify").args(system.listeners, EVENT_LOG);

                    system.service("notify").args(system.encapsulators, EVENT_LOG);

                    system.service("notify").args(system.registrars, EVENT_LOG);

                    //
                }
            }

            //

            This looks fine; as we basically are care here toward a simple system alteration. There is a Copier SystemComponent that requires some input, a transaction for a Bank let's imagine, and this way added, at original design time, a way

            for a Backup SystemComponent to get a copy ahead of the rest of the system continuing in doing the actual bank transfer call.  In this case we clearly are in an area for security concern.  The system development team would have to design a circuit aware

            system

            Example 5: Running out of Time

            Here we would look at some cases where the best assumed human effort would cause malfunction: the system would have to brought down and manually configured.  We would look at this as a directed graph, best vs worst case scenario against our list of SystemComponent modules.

            Before beginning we would care to stress that finally we care to adjust reference documents and that these documents should change as required.  As we learn a valuable axiom, corollary we would make adjustment toward these truths in the reference manual.

            These in turn would form something like truth tables and just-in-time references for you as a developer.  These we would hold as important.  A complete work up might take some four to six months, not more.  Working through some best and worst cases we would find helpful in starting

            toward a science of design for software.  Here the Engineer would stand, the developer would learn.  Ok.

            //

            The first case we care to entertain is that one action will preclude unknowably some other action.  ClientImpl001 will then require some reset of process that will oblique another user or process.  The client will request a change of resource

            that is now either changed or is part of another flow that precludes the second item from getting any service.  For instance we have a Grader for determining whether a JSON input is well formed; this Grader will have then some interested parties.

            The Grader is then rewired as being later in the process flow and the Monitor it was using now gets no action as there is another Grader is written to only flow data that is indeed correct.  Ok, so this case is a bit contrived but here we no feedback for

            a government organization that is legally required to implement a Monitor all transaction data, valid requests or not.

            //

            public class Network
            {
                public Network(System system, ...)
                {
                    ... //
                }


            }

            //

            The second case is a race-condition; the polite user is not getting any attention.  He does all that is required, does it well and on time and sees that his results are not getting enough of the processor time.  The subject here is that another user knows

            that a protocol is more flexible than previously considered.  The system has no logic circuit to detect it and no observer to know about it.  The circuit specifically cannot guarantee a proportional opportunity because, in addition to requesting a data process

            there is some other condition that is being entered. Below a condition the circuit will have an expectation that will not be met; there will be a function that will eventually depend on two competing methods.  We will look here at a complete example.  This space is

            rich for PhD research and for system theory itself.  Basically the system will seem right but some part of it will be subject to a nuance that will be difficult to detect.  Indeed how close we can come to a fair, secure implementation that will

            guard a humanistic appraisal of contract would be itself rich territory for ethics, business and theory.  Let's have a look at some examples:

            //

            public class Server extends SystemComponent implements Swappable
            {
                ... //

                ArrayList<SystemComponent> components;

                public Server(System system, ...)
                {
                    ... //
                }

                @Override
                public void swap(Object one, Object two)
                {
                    org.our.System.event("Server "+this.hashCode()+" starts swap for object "+one+" and object "+two);

                    Object temp;

                    temp = one;

                    one = two;

                    two = temp;

                    org.our.System.event("Server "+this.hashCode()+" swapped object "+one+" for object "+two);
                }
            }

            //

            This object is simpler than we might find in the wild and so we might argue that it is more contrived than is strictly necessary.  The overarching position is that there is a potential system or application call that will put, alter or remove a value, object or component without having

            a static way to state it.  The potential reach of the system must then be reducible to quantifiable calculus so we step carefully to avoid race-conditions in the software.  Again the circuit and XML/JSON to form a rules document would be

            well held.  Then the potential reach of the system should be fair in terms of time, in terms of trade and in terms of scale.  A complete systems approach would care here.  Let's take a quick look at a XML document that would allow a contractual grade

            Guarantor to be written.

            //

            <logic type="rules">

                <time>

                ...

                </time>

                <trade>

                ...

                </trade>

                <scale>

                ...

                </scale>

            </logic>

            //

            The third case is knowing whether a particular alteration is a priori correct.  The system cannot guarantee a contract toward working order ahead if we allow any SystemComponent ordering in the system.

        ic. Post-Design Time

        id. Runtime

        ie. Errata

    We issue then in keeping with standard ordering logic the following:

        a. In extensible set a component must be

        b. In extensible set a component must be

    ii.     Direct System Related Extensibility Mapping

    The backing system is the object here; as we add to the program we need the extensibility in terms of speed and ease.  We add functionality in terms of understanding to maintain this edge in the sort.

    iii.    Indirect System Related Extensibility Mapping

    The programmer and/or designer are the object here.  Clear cut case of adding complexity by adding external constraints that are not a direct system value.

    iv.     Reorganization and Cleanliness

II. Specific Extensibilities

Certain patterns will have specific

III.

In the general case there will be 3 to 5 states that will be guarded before decided if a particular implementation will be safe for system development.  The first case is the concrete class; we should all now be familiar with a concrete class.

A concrete class will be a class itself or a class that implements a interface guarantee.  The concrete class is problematic in that it will only guarantee a rigid structure.  The provides some positive benefits insofar as the programmer is concerned.

The program will be easily read and implemented by programmers.  It will have so many options and so many ways before you have exhausted the extensible nature of the object.  In the very general case we end up using the SystemComponent object

as a backing class to provide maximum utility to a concrete class so we do not run into design issues.

//

In the second case we have a way for adding system and component function to a class implementation.  In such cases we would like to know about the object from the third person point-of-view; that is we should carry it well for the abstract case as well, not just our immediate reference.

And so it becomes clear then that we should examine the degree of required extensibility before deciding on patterns I, II or III, etc.  In this case we should look to understand a requirement and implementation diagram or proposal ahead of pulling out the 3 iron and just going for it.

What will become clear as we continue is that we have some recurring problems in the software space but that naturally we would want to favor a perfect or very well written system.  In this case we would look to add support

in terms of functionality, degree and/or reference.  Let's just set that for now.  Your class will be more or less extensible in terms of these things.  So in taking up Java we see that it is good for some things while behind in others.

For term we should consult that a function is normally very concrete; it is a structural member very usually and inherited or otherwise.  There are no pointers to functions as C or C++ implements.  So in stepping up a degree in extensibility to meet

this functional extensible we should understand the costs and angles for calculation. Let's just take a quick look at how this typically goes and see if we can graduate a concept of few:

//

public class Endpoint extends SystemComponent implements Runnable, Pausable, ... //
{
    ... //

    @Override
    public void run()
    {
        ... //
    }

    @Override
    public void pause()
    {
        ... //
    }
}

Here is the standard case; you would write a class that has some interface for a system or the like and you would have a more or less steady target to aim at.  Many of such classes would suggest a strong system backend and perhaps suggest a strongly conceived approach.

If we wanted then to add functionality on the fly we have basically two approaches.  Firstly we could implement something like:

//

public class Endpoint extends SystemComponent implements Runnable, Pausable, ... //
{
    public Function<Runnable> runnable;

    public Function<Pausable> pausable;

    ... //

    @Override
    public void run()
    {
        ... //

        runnable.run();

        ... //
    }

    @Override
    public void pause()
    {
        ... //

        pausable.pause();

        ... //
    }
}

This makes few assumptions about the state of the object (the instance) as the Runnable and Pausable do not directly infer or rely directly on any other class members.  So this way indeed might be safe and friendly; ideal.  Here

we have public, let us say for speed, members that can be simply swapped out.  This is fine for now however later we can look at some issues with keeping members public.  Ok, for now.

The other example would be to call a system component and ask for a specific functional object to be created on the fly.  We could have then minor variants in functional aspect that are housed in the object that we return as concrete references.

//

public class Endpoint extends SystemComponent implements Runnable, Pausable, ... //
{
    ... //

    @Override
    public void run()
    {
        ... //

        concrete code

        ... //
    }

    @Override
    public void pause()
    {
        ... //

        concrete code

        ... //
    }
}

//

If there is a nagging doubt about how this would indeed work; go with it.  We don't need a perfect value here we need instead the correct intuition.  And instead of getting stuck go ahead and see what technology will allow you; you working the problem yourself.

Therefore then the system call may look like:

public class ClientImpl extends SystemComponent implements Runnable, Pausable, ... /
{
    ... //

   @Override
   public void run()
   {
        //

        org.our.System.api("/api/project/system/classes/EndpointFactory").store("jndi://localhost:8080/team/store/id", "/project/system/objects/Endpoint00056").args("rules.xml", "standard.implementation.bak").run();

        //

        org.our.System.api("/api/project/system/classes/EndpointValidator").store("jndi://localhost:8080/team/store/id", "/project/system/objects/Validation00056").args("validation_rules.xml", "/project/system/objects/Endpoint00056").run();

        //

        org.our.System.api("/api/project/system/classes/ResultRegistrar").store("jndi://localhost:8080/team/store/id", "/project/system/objects/Result00056").args("result_registrar_rules.xml", "/project/system/objects/Validation00056").run();

        //

        org.our.System.api("/api/project/system/classes/SystemComponentRegistrar").store("jndi://localhost:8080/team/store/id", "/project/system/objects/SystemRegistration00056").args("https://rules/system_component_registrar_rules.xml", "/project/system/objects/Object00056").run();

        //

        org.our.System.api("/api/project/system/classes/SystemEventRegistrar").store("jndi://localhost:8080/team/store/id", "/project/system/objects/SystemEventRegistration00056").args("event_rules.xml", "/project/system/objects/Object00056").run();

        ... //
   }
}

This looks fine for now.  You see we have an API call to get a reference to a function house by a classname.  We have some quick JNDI storage for values that we will care to reference ahead.  We have some arguments that may go into these functions as well.

Mainly for now we care to issue to you the notion that we can specify deeply the runtime characteristics of a org.yours.name.Classname by simple factory at runtime.  The factory then can relate some event, validation or similar functional data to the system and we can get on with life

without relying on old or dirty secrets again and again.

Terms:

Swith: Super-smooth, low-latency coolness,, again

Darth: Break-even point for emperor

