Extensibility:

I. Standard Extensibilities

Many patterns naturally will relate function and structure in general ways which we can understand.  Understanding these well in terms of design and extensibility is the difference between a job and a doingness. Let's take a look at how these break down.

    i.      Relating Supercomplexity toward Swith*

    Here we issue toward reuse of standard patterns in terms their manifold across and relating to the patterns issued at design and post-design time - specifically where these extend structure and therefore function beyond the simple interlinking of well understood pattern(s).

    We issue then in keeping with standard ordering logic the following:

        a. You will add components to a component

        b. You will add components to a series of components

        c. You will add components to a queue or very similar

        d. You will add components to a system or very similar

        e. You will add components to a logic

        f. You will add custom components

        g. You will add components pre/post/during design time

        h. You will need to consider connectors for such additions

        //

        a. You will latch components

        b. You will latch subcomponents

        c. You will latch applications

        d. You will latch systems

        e. You will latch networks

        f. You will latch protocols

        //

        a. You will make more or less public a component and/or system etc.

        b. You will make more or less private a component and/or system etc.

        c. You will make more or less protected a component and/or system etc.

        d. You will make more or less commutative a component and/or system etc.

        e. You will make more or less transitive a component and/or system etc.

        f. You will make more or less reflexive a component and/or system etc.

        //

        a.  You will want to offer a reference across a simple circuit and/or component

        b.  You will want to offer a reference across a complicated circuit and/or component

        c.  You will want to offer a reference across a privately held circuit and/or component

        d.  You will want to offer a reference across a shared circuit and/or component

        e.  You will want to offer re-reference across these items

        f.  You will want to add such values at runtime

        g.  You will want to add such values at compile time

        //

        a. You will want to move system components through transitivity ( question of how it will be there - time based or logic )

        b. You will want to move system components through commutativity ( question of ordering relation )

        c. You will want to move system components through reflexivity ( question of self-knowledge )

        d. You will want to move system components through

        //

        a. You will want a way to generalize system functionalities to form definition of minimal complete set

        b. You will want a way to classify system functionalities to claim form minimal complete set

        c. You will want a way to show where extends keyword is useful and why

        d. You will want a way to show where implements keyword is useful and why

        e. You will want a way to show where component features/commonalities are redundant or already concerted

        f. You will want a way to show where adding more system feature will cause a refactoring

        g. so on A+ really good so far@

        //

    Each of these will be a carry object.  We will take a look now at what this means for you, the developer.  As we progress in understanding the objects we intuit tend to mature as well.  These items will remain constant; you will expect to carry them in the delta set for reference.

    Now we need to shape our perspectives.  In what way then best to understand the relating pattern of adding, removing or altering components at pre/post/during design time, at runtime, across the permute of the list above?

        ia. Pre-Design Time

        Here we have s strong case for getting it all right to begin with.  Strong exceptions will be later adding unforeseeable requirements, lack of understandingness for it, or adding new developers or development processes. The objects here will be about gathering concepts and feelings about it the early fill-space we will conquer.

        The good or strong extensible set will maintain extensible features well.  What we will consider is how extensible the system should be.  We want the complete list of attributes to consider ahead of design time.  Here they are:

            a.  The object will need referencing

            b.  The object will need pointer reference

            c.  The object will need to be moved

            d.  The object will need a new degree of extensibility

            e.  The object will need lock(s) and/or locking features

            f.  The object will need to be encapsulated

            g.  The object will need to support an interface

            h.  The object will need a support mechanism (protocol or protocols)

            i.  The object will need to support a varying workload

            j.  The object will need to support scheduling

            k.  The object will need to use / infer logic

        These are considered two ways.  The programmer will want a clean way to move values in the 2-space of design.  The software itself will need a way to handle these at runtime.  Thus we address three things: the application, the system application and the system for design.

        Here you will want to gather system design documents that will help you guide the process towards safe and thorough completion for each step.  These documents and/or references should be read and understood by all group members ahead of starting on design proposal.

        ib. Design Time

            a. You will want to make a list of human addressables; these will be the human concept of what will be going on.  You will want to keep a design folder and a copy that show the design and theory for each step as you proceed through design and revision.

            How detailed a folder is more than subjective.  You will want something like 10 pages per design object.  You will want to create a circuit diagram, a basic write up and supporting theory for why the process supports that program, finally you will want a page stating which architects and/or designers were involved.

            This will become more interesting and usual to you as you work through the process of system and locating system components against a well understood logic for basis.  A good architect will have many successful folders illustrating his design approach and processes.  If it seems to easy you probably did not do enough work on predesign.

            //

            Example 1:  User Interface Apportionment

            Studying the field of user interfaces we see they usually are designed some three different ways.  The first way will have a monitor for actions with subscribers and listeners.  The second way will be a slightly more systematic approach and the third way would have a very systematic approach.

            These might be then that a browser will have a buttons or input dialogs written in native C or C++.  Inside the browser we find that the scripting engine indeed transfers this process to XML/HTML.  That we can rely on a system mechanism like onclick() to transfer control to a fucntion of our choosing.

            We will find above this there is indeed a total requirement for a system to manage greater system complexity.  This is where design comes into the picture.  Further we can isolate other important factors such as the degree of imposition on locating the callbacks in a system.

            //

            The boss comes to you and suggests you create a user interface proposal.  You can a) write all the code by hand and hope the complexity requirements are met by simple callback functionality, b) write an interpreter that will help you manage development complexity or c) rely on a strong system for component management.

            The case for writing it by hand is clear; you will have total control and responsibility.  An interpretive layer would also be good; you would rely on a shorthand completion for many builds and finally connect any idiosyncracies by hand for final design. The proposal would itself be helped by an XML/HTML implementation as it is easily read by human conceptual preconceptual.

            The final case is a very powerful tool for it; you can complete functional code and locate it in a mapped index.  Each functional component can be called by name and by reference as we grow the method for answering button clicks and the like.  Let's look at how far each can go in stable atmosphere before running into technical challenges.

             //

             a. By Hand

             The application will require a minimum relation with a system backing that will allow motive in relation to system components and that theory.  We would state that safely the functional code should be stored in a Function object that has a mapped property and a lookup mechanism for that function to answer some method towards response.

             There may be many systems that attend the state of execution for a button press.  There may be many dependencies on a system state and that, in turn, on behalf of some human interaction.  This to say that we will be attending some common practices to make sure we support a general method deep enough for a system architect to interface with and repeatable enough to see value in scripting and that thing.

             //

             The locking mechanism for the system state should be global and well named.  We should have a method to access it within the source code and within scripting.  We should have a relative affluence in system space with respect toward application requirements.

             The three values here are:

             i.     Unlock locked system state

             Here we state that there is a lock of finite complexity; forever locks that end up deadlocking the process itself we don't address here.  However the system will require two plumbings; one for the application and one for the system.  So a developer would be responsible for stating and characterizing the circuit for unlock and lock of his function(s).

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system blocking a threaded process.  Many things could be locked and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup condition.  We would then vie for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a person's circuit will be as large as is required and not more.


             ii.    Transfer locked system state

             Here we state that there is a lock of finite scope; locks that end up changing during transfer process we don't address here.  However the system will require two plumbings; one for transfer of reference and one for a transfer of binary code.  So a developer would be responsible for stating and characterizing the circuit for transfer under normal and failure conditions for both rereferncing and binary exchanges.

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system blocking a threaded process.  Many things could be related and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup or existing condition.  We would then care to manage reservations for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a program's circuit will be as large as is required and not more.


             iii.   Normal process (lock and unlock normally)

             Here we state that there is a lock of finite complexity; intractable locks that end up deadlocking the process or system reach itself we don't address here.  However the system will require two plumbings; one for the application and one for the system.  So a developer would be responsible for stating and characterizing the circuit for unlock and lock of his function(s).

             The system developer would need to read the description of the circuit and the application code that goes with it.  Here he would architect a unlock sequence for emergencies for example; or perhaps for simple transfer to another system a blocking threaded process.  Many things could be locked and by degree many things would have to be written carefully.

             Basically we address however the system's ability to recover from locked condition and transfer of control back to application as would be considered safe and complete by a given startup condition.  We would then vie for monitors and registrars for exceptions and state transfer(s) by system and application.

             So adding these up into system cognate we find we approach some bounded complexity and a likeness to circuitry.  We close by stating that these will usually be reducible to prototypical conducts; that a person's circuit will be as large as is required and not more.

             //

             Summarily we need then a scope of circuit, data and application function separation, application circuitry for standard start, restart, pause and stop, system circuitry for standard start, restart, pause and stop, listeners for errors, listeners for exceptions, listeners for state, listeners for state transfers and perhaps more.

             If you try to write these all by hand it may become tedious and best-case vs worst-case scenarios will not always be known.  Further minor design variations will have major shifts in design if we are not careful and patience will be consumed ahead of schedule.

             Let's look at a quick example then for a button, continuing with these themes elsewhere.

             //

             public class Button0001 extends JButton
             {
                    public Button0001(System system, JComponent parent)
                    {
                        //setters

                        //application calls

                        //system calls
                    }

                    ...

                    public CircuitGuard cg_application;

                    public CircuitGuard cg_system;

                    public System system;

                    public SystemIntegrand i_system;

                    ...

                    public void actionPerformed(ActionEvent ae)
                    {
                        //stub code
                    }
             }

             //

             b. Quick Interpretive

             c. Full Interpretive

            Finally the strong case

            Example 2:  Network Interface Apportionment



            Example 3:

        ic. Post-Design Time

        id. Runtime

        ie. Errata

    We issue then in keeping with standard ordering logic the following:

        a. In extensible set a component must be

        b. In extensible set a component must be

    ii.     Direct System Related Extensibility Mapping

    The backing system is the object here; as we add to the program we need the extensibility in terms of speed and ease.  We add functionality in terms of understanding to maintain this edge in the sort.

    iii.    Indirect System Related Extensibility Mapping

    The programmer and/or designer are the object here.  Clear cut case of adding complexity by adding external constraints that are not a direct system value.

    iv.     Reorganization and Cleanliness

II. Specific Extensibilities

Certain patterns will have specific


Terms:

Swith: Super-smooth, low-latency coolness,, again

Darth: Break-even point for emperor

